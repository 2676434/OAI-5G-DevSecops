#!/bin/groovy
/*
 * Licensed to the OpenAirInterface (OAI) Software Alliance under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The OpenAirInterface Software Alliance licenses this file to You under
 * the OAI Public License, Version 1.1  (the "License"); you may not use this file
 * except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.openairinterface.org/?page_id=698
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *-------------------------------------------------------------------------------
 * For more information about the OpenAirInterface (OAI) Software Alliance:
 *      contact@openairinterface.org
 */

// Location of the CN executor node
def cn_ci_host = params.Host_CN_CI_Server
def cn_ci_resource = params.DockerContainers

// Location of the gNB node
def gnb_server = params.gnb_server
def gnb_resource = params.gnb_resource

// Location of the COTS UE control node
def ue_ctl_server = params.ue_ctl_server
def ue_ctl_resource = params.ue_ctl_resource

//
def upstreamEvent = false
upstreamTagToUse = params.upstreamTagToUse

// Variables that can used in main pipeline and in functions
NRF=0
AMF=1
SMF=2
UPF=3
AUSF=4
UDM=5
UDR=6

// Default tags / branches  --> could be passed on by upstream job
imageNames = ["oai-nrf", "oai-amf", "oai-smf", "oai-upf", "oai-ausf", "oai-udm", "oai-udr"]
repoNames = ["oai-cn5g-nrf", "oai-cn5g-amf", "oai-cn5g-smf", "oai-cn5g-upf", "oai-cn5g-ausf", "oai-cn5g-udm", "oai-cn5g-udr"]
branchNames = ["", "", "", "", "", "", ""]
imageTags = ["", "", "", "", "", "", ""]
upstreamJobs = [false, false, false, false, false, false, false]
pulledImages = [false, false, false, false, false, false, false]
containerNames = ["oai-nrf", "oai-amf", "oai-smf", "oai-upf", "oai-ausf", "oai-udm", "oai-udr", "oai-ext-dn"]

// Status booleans
boolean deployedCore = false
boolean deployedGNB  = false
boolean coreDeploy   = true
boolean gnbDeploy    = true
boolean testStart0   = true
boolean testStart1   = true
boolean testStop0    = true
boolean testStop1    = true

//-------------------------------------------------------------------------------
// Pipeline start
pipeline {
  agent {
    label cn_ci_host
  }
  options {
    disableConcurrentBuilds()
    timestamps()
    ansiColor('xterm')
    lock(extra: [[resource: gnb_resource]], resource: cn_ci_resource)
  }
  stages {
    stage ('Verify Parameters') {
      steps {
        script {
          echo '\u2705 \u001B[32mVerify Parameters\u001B[0m'

          JOB_TIMESTAMP = sh returnStdout: true, script: 'date --utc --rfc-3339=seconds | sed -e "s#+00:00##"'
          JOB_TIMESTAMP = JOB_TIMESTAMP.trim()

          echo "Node       is ${NODE_NAME}"

          // Find out the cause of the trigger
          for (cause in currentBuild.getBuildCauses()) {
            if (cause.toString().contains('UpstreamCause')) {
              upstreamEvent = true
            }
            if (cause.toString().contains('OAI-CN5G-NRF')) {
              upstreamJobs[NRF] = true
            }
            if (cause.toString().contains('OAI-CN5G-AMF')) {
              upstreamJobs[AMF] = true
            }
            if (cause.toString().contains('OAI-CN5G-SMF')) {
              upstreamJobs[SMF] = true
            }
            if (cause.toString().contains('OAI-CN5G-UPF')) {
              upstreamJobs[UPF] = true
            }
            if (cause.toString().contains('OAI-CN5G-AUSF')) {
              upstreamJobs[AUSF] = true
            }
            if (cause.toString().contains('OAI-CN5G-UDM')) {
              upstreamJobs[UDM] = true
            }
            if (cause.toString().contains('OAI-CN5G-UDR')) {
              upstreamJobs[UDR] = true
            }
          }
          sh "git clean -x -d -f > /dev/null 2>&1"
          sh "git submodule foreach --recursive 'git clean -x -d -ff' > /dev/null 2>&1"
          sh "git submodule deinit --force --all > /dev/null 2>&1"
          // For any upstream job (PR or post-merge), let run on certified tag.
          if (upstreamEvent) {
            sh 'git checkout -f ' + upstreamTagToUse
          }
          sh 'git submodule update --init --recursive ci-scripts/common'
          sh "mkdir -p archives"

          for (ii = 0; ii < imageNames.size(); ii++) {
            if (ii == NRF) {
              branchNames[NRF] = params.NRF_BRANCH
              imageTags[NRF] = params.NRF_TAG
              if (upstreamEvent && upstreamJobs[NRF]) {
                echo "Upstream Job passed NRF_TAG to use: ${imageTags[NRF]}"
                echo "Upstream Job passed NRF_BRANCH to use: ${branchNames[NRF]}"
              }
            }
            if (ii == AMF) {
              branchNames[AMF] = params.AMF_BRANCH
              imageTags[AMF] = params.AMF_TAG
              if (upstreamEvent && upstreamJobs[AMF]) {
                echo "Upstream Job passed AMF_TAG to use: ${imageTags[AMF]}"
                echo "Upstream Job passed AMF_BRANCH to use: ${branchNames[AMF]}"
              }
            }
            if (ii == SMF) {
              branchNames[SMF] = params.SMF_BRANCH
              imageTags[SMF] = params.SMF_TAG
              if (upstreamEvent && upstreamJobs[SMF]) {
                echo "Upstream Job passed SMF_TAG to use: ${imageTags[SMF]}"
                echo "Upstream Job passed SMF_BRANCH to use: ${branchNames[SMF]}"
              }
            }
            if (ii == UPF) {
              branchNames[UPF] = params.UPF_BRANCH
              imageTags[UPF] = params.UPF_TAG
              if (upstreamEvent && upstreamJobs[UPF]) {
                echo "Upstream Job passed UPF_TAG to use: ${imageTags[UPF]}"
                echo "Upstream Job passed UPF_BRANCH to use: ${branchNames[UPF]}"
              }
            }
            if (ii == AUSF) {
              branchNames[AUSF] = params.AUSF_BRANCH
              imageTags[AUSF] = params.AUSF_TAG
              if (upstreamEvent && upstreamJobs[AUSF]) {
                echo "Upstream Job passed AUSF_TAG to use: ${imageTags[AUSF]}"
                echo "Upstream Job passed AUSF_BRANCH to use: ${branchNames[AUSF]}"
              }
            }
            if (ii == UDM) {
              branchNames[UDM] = params.UDM_BRANCH
              imageTags[UDM] = params.UDM_TAG
              if (upstreamEvent && upstreamJobs[UDM]) {
                echo "Upstream Job passed UDM_TAG to use: ${imageTags[UDM]}"
                echo "Upstream Job passed UDM_BRANCH to use: ${branchNames[UDM]}"
              }
            }
            if (ii == UDR) {
              branchNames[UDR] = params.UDR_BRANCH
              imageTags[UDR] = params.UDR_TAG
              if (upstreamEvent && upstreamJobs[UDR]) {
                echo "Upstream Job passed UDR_TAG to use: ${imageTags[UDR]}"
                echo "Upstream Job passed UDR_BRANCH to use: ${branchNames[UDR]}"
              }
            }
          }

          // On Ubuntu servers, we shall pull from private local registry
          if ((cn_ci_host == 'selfix') || (cn_ci_host == 'orion') || (cn_ci_host == 'alambix') || (cn_ci_host == 'cetautomatix')) {
            pullFromSelfix = true
            try {
              // Login
              sh 'docker login -u oaicicd -p oaicicd selfix.sboai.cs.eurecom.fr > /dev/null 2>&1'
            } catch (Exception e) {
              echo 'Problem w/ selfix registry. Let see if we can use local images'
              pullFromSelfix = false
            }
            if (pullFromSelfix) {
              // We will try to pull from selfix registry.
              // If the NF CI is yet ready, it's OK, it will fail but keep working with local registry
              for (ii = 0; ii < imageNames.size(); ii++) {
                imageTags[ii] = pullImageFromSelfix(ii, imageNames[ii], imageTags[ii], branchNames[ii])
              }
              // Logout
              sh 'docker logout selfix.sboai.cs.eurecom.fr > /dev/null 2>&1'
            }
          }

          // Verify that the images are available
          imageStatus = 0
          for (ii = 0; ii < imageNames.size(); ii++) {
            imageStatus += checkImageInfo(imageNames[ii], imageTags[ii])
          }
          if (imageStatus > 0) {
            error ("Some images are not present!")
          }
        }
      }
    }
    stage ('Deploy CN5G') {
      steps {
        script {
          echo '\u2705 \u001B[32mDeploy CN5G\u001B[0m'
          dir ('ci-scripts/docker-compose/cn5g-ci-testbed-ebpf') {
            sh "sudo rm -f /tmp/oai-cn5g-ebpf.pcap /tmp/oai-cn5g-ebpf.logs"
            updateDockerCompose('docker-compose.yaml')
            sh "./add-route-to-gnb-on-dogmatix.sh"
            sh "docker compose up -d"
            sh 'nohup sudo tshark -i demo-oai -i demo-n3 -i demo-n6 -w /tmp/oai-cn5g-trace.pcap > /tmp/oai-cn5g-trace.logs 2>&1 &'
            sh '../../checkContainerStatus.py --container_name mysql --timeout 40'
            sh '../../checkContainerStatus.py --container_name oai-upf --timeout 40'
            sh "docker compose ps -a"
            deployedCore = true
          }
        }
      }
    }
    stage ('Deploy gNB') {
      agent { label gnb_server }
      steps {
        script {
          echo '\u2705 \u001B[32mDeploy gNB\u001B[0m'
          // As mentioned in the job configuration
          // FULL_RAN_TAG shall be of "pullable" image format
          // either porcepix.sboai.cs.eurecom.fr/oai-gnb:ci-tag
          // or     oaisoftwarealliance/oai-gnb:week-tag
          // It may temporarly be of porcepix.sboai.cs.eurecom.fr/oai-gnb:raphael/ci-fix-ubuntu-build-log-scheme-24efc76d format
          //   the raphael/ part shall be fixed to raphael-
          ranFullImage = fixFullRanImageTag(params.FULL_RAN_TAG)
          checkAndPullRanImage(ranFullImage)
          sh 'mkdir -p archives'
          sh "echo 'Tested Tag is ${ranFullImage}' > archives/oai-gnb-image-info.log"
          sh "docker image inspect --format='Date = {{.Created}}' ${ranFullImage} >> archives/oai-gnb-image-info.log"
          sh "docker image inspect --format='Size = {{.Size}} bytes' ${ranFullImage} >> archives/oai-gnb-image-info.log"
          sh "echo 'OC Pushed Tag is N/A' >> archives/oai-gnb-image-info.log"
          stash allowEmpty: true, includes: 'archives/oai-gnb-image-info.log', name: 'gNB_image'
          // Adding capture on SCTP and L2 port 9999
          sh "sudo rm -f /tmp/oai-gnb-l2-trace.pcap /tmp/oai-gnb-l2-trace.logs"
          sh 'nohup sudo tshark -i demo-oai -i demo-n3 -f "sctp or udp port 9999" -w /tmp/oai-gnb-l2-trace.pcap > /tmp/oai-gnb-l2-trace.logs 2>&1 &'
          sleep 2
          // Deploying now
          dir ('ci-scripts/docker-compose/gnb-ci-testbed-ebpf') {
            sh "./add-route-to-cn5g-on-selfix.sh"
            sh "sudo b2xx_fx3_utils --reset-device"
            sh "sudo uhd_find_devices > /dev/null 2>&1 || true"
            sleep 5
            sh "sed -i -e 's@image: oaisoftwarealliance/oai-gnb:develop@image: ${ranFullImage}@' docker-compose.yaml"
            sh "docker-compose up -d"
            deployedGNB = true
            gNBStatus = checkStatusOnGNB()
            if (gNBStatus > 0) {
              error ("gNB did NOT deploy properly")
            }
          }
        }
      }
      post {
        success {
          script {
            gnbDeploy    = true
          }
        }
        unsuccessful {
          script {
            sh "sudo pkill tshark || true"
            sleep 2
            sh "sudo chmod 666 /tmp/oai-gnb-l2-trace.* || true"
            dir ('ci-scripts/docker-compose/gnb-ci-testbed-ebpf') {
              sh "docker-compose stop -t 3 || true"
              sleep 2
              sh "docker logs sa-b210-gnb > oai-gnb.logs 2>&1 || true"
              sh "cp /tmp/oai-gnb-l2-trace.* . || true"
              sh "sudo rm -f /tmp/oai-gnb-l2-trace.*"
              stash allowEmpty: true, includes: 'oai-gnb.logs, oai-gnb-l2-trace.*', name: 'gNB_logs'
              sh "docker-compose down -t 3 || true"
              sh "./remove-route-to-cn5g-on-selfix.sh || true"
            }
            deployedGNB  = false
            gnbDeploy    = false
            testStart0   = false
            testStart1   = false
            testStop0    = false
            testStop1    = false
            if (ranFullImage.contains('porcepix')) {
              sh "docker rmi ${ranFullImage} || true"
            }
          }
        }
      }
    }
    stage ('Test COTS-UE') {
      agent { label ue_ctl_server }
      steps {
        lock(ue_ctl_resource) {
          script {
            echo '\u2705 \u001B[32mTest COTS-UE\u001B[0m'
            sh 'mkdir -p archives'
            dir ('ci-scripts/cots-ue-mbim-scripts') {
              // I don't want that stage to fail.
              // It's easier then to un-deploy gNB.
              try {
                sh 'sudo bash -c "set -o pipefail && ./start.sh 2>&1 | tee /tmp/test-start0.log"'
              } catch (Exception e) {
                echo "Test-Start #0 seems to have failed!"
                testStart0 = false
              }
              if (testStart0) {
                sh 'sudo traceroute -4 -T -i wwan0 openairinterface.org | tee /tmp/test-traffic0.log'
                sh 'curl --interface wwan0 https://openairinterface.org/wp-content/uploads/2015/06/cropped-oai_final_logo.png -o /tmp/test-oai_final_logo.png'
              }
              try {
                sh 'sudo bash -c "set -o pipefail && ./stop.sh 2>&1 | tee /tmp/test-stop0.log"'
              } catch (Exception e) {
                echo "Test-Stop #0 seems to have failed!"
                testStop0 = false
              }
              sleep 5
              try {
                sh 'sudo bash -c "set -o pipefail && ./start.sh 2>&1 | tee /tmp/test-start1.log"'
              } catch (Exception e) {
                echo "Test-Start #1 seems to have failed!"
                testStart1 = false
              }
              try {
                sh 'sudo bash -c "set -o pipefail && ./stop.sh 2>&1 | tee /tmp/test-stop1.log"'
              } catch (Exception e) {
                echo "Test-Stop #1 seems to have failed!"
                testStop1 = false
              }
            }
            sh 'sudo chmod 666 /tmp/test-st*.log'
            sh 'cp -f /tmp/test-*.log /tmp/test-*.png archives || true'
            sh 'sudo rm -f /tmp/test-*.log /tmp/test-*.png || true'
            stash allowEmpty: true, includes: 'archives/*.*', name: 'ue_logs'
          }
        }
      }
    }
    stage ('Undeploy gNB') {
      agent { label gnb_server }
      steps {
        script {
          echo '\u2705 \u001B[32mUndeploy gNB\u001B[0m'
          if (deployedGNB) {
            sh "sudo pkill tshark || true"
            sleep 2
            sh "sudo chmod 666 /tmp/oai-gnb-l2-trace.* || true"
            dir ('ci-scripts/docker-compose/gnb-ci-testbed-ebpf') {
              ranFullImage = fixFullRanImageTag(params.FULL_RAN_TAG)
              sh "sed -i -e 's@image: oaisoftwarealliance/oai-gnb:develop@image: ${ranFullImage}@' docker-compose.yaml"
              sh "docker-compose stop -t 3 || true"
              sleep 2
              sh "docker logs sa-b210-gnb > oai-gnb.logs 2>&1 || true"
              sh "cp /tmp/oai-gnb-l2-trace.* . || true"
              sh "sudo rm -f /tmp/oai-gnb-l2-trace.*"
              stash allowEmpty: true, includes: 'oai-gnb.logs, oai-gnb-l2-trace.*', name: 'gNB_logs'
              sh "docker-compose down -t 3 || true"
              sh "./remove-route-to-cn5g-on-selfix.sh || true"
            }
            deployedGNB = false
            if (ranFullImage.contains('porcepix')) {
              sh "docker rmi ${ranFullImage} || true"
            }
          }
        }
      }
    }
    stage ('Undeploy CN5G') {
      steps {
        script {
          echo '\u2705 \u001B[32mUndeploy CN5G\u001B[0m'
          unstash 'ue_logs'
          unstash 'gNB_image'
          unstash 'gNB_logs'
          if (fileExists('oai-gnb.logs')) {
            sh 'mv oai-gnb.logs archives'
          }
          if (fileExists('oai-gnb-l2-trace.pcap')) {
            sh 'mv oai-gnb-l2-trace.* archives'
          }
          dir ('ci-scripts/docker-compose/cn5g-ci-testbed-ebpf') {
            updateDockerCompose('docker-compose.yaml')
            sh "docker compose stop -t 30"
            for (ii = 0; ii < containerNames.size(); ii++) {
              sh "docker logs " + containerNames[ii] + " > ../../../archives/" + containerNames[ii] + ".logs 2>&1"
            }
            sh "docker compose down -v"
            sleep 5
            sh "sudo chmod 666 /tmp/oai-cn5g-trace.*"
            sh 'cp /tmp/oai-cn5g-trace.* ../../../archives'
            sh "sudo rm -f /tmp/oai-cn5g-trace.*"
            cleanUpDockerCompose('docker-compose.yaml')
            sh "./remove-route-to-gnb-on-dogmatix.sh || true"
          }
        }
      }
    }
  }
  post {
    always {
      script {
        // Zipping all archived log files
        sh "zip -r -qq cn5g_fed_ebpf_logs.zip archives"
        if (fileExists('cn5g_fed_ebpf_logs.zip')) {
          archiveArtifacts artifacts: 'cn5g_fed_ebpf_logs.zip'
        }
        //sh './ci-scripts/checkTutorialHtmlReport.py --job_name ' + JOB_NAME + ' --job_id ' + BUILD_ID + ' --job_url ' + BUILD_URL
        //if (fileExists('test_results_oai_cn5g_tutorials.html')) {
        //  archiveArtifacts artifacts: 'test_results_oai_cn5g_tutorials.html'
        //}
      }
    }
    cleanup {
      script {
        sh 'docker volume prune --force'
        // Removing the images that we pulled.
        for (ii = 0; ii < imageNames.size(); ii++) {
          if (pulledImages[ii]) {
            sh 'docker rmi ' + imageNames[ii] + ':' + imageTags[ii]
          }
        }
      }
    }
  }
}

def pullImageFromSelfix(idx, imageName, imageTag, branchName) {
  if ((imageTag == 'develop') && (branchName == 'develop')) {
    try {
      tag = sh returnStdout: true, script: './ci-scripts/retrieveLatestTagOnPrivateRepo.py --repo-name ' + imageName
      tag = tag.trim()
    } catch (Exception e) {
      return imageTag
    }
  } else {
    tag = imageTag
  }
  // We may have wrong image tag?
  try {
    sh 'docker pull selfix.sboai.cs.eurecom.fr/' + imageName + ':' + tag
    sh 'docker image tag selfix.sboai.cs.eurecom.fr/' + imageName + ':' + tag + ' ' + imageName + ':' + tag
    sh 'docker rmi selfix.sboai.cs.eurecom.fr/' + imageName + ':' + tag
    pulledImages[idx] = true
  } catch (Exception e) {
    echo "${imageName} Image tag to test (${imageName}:${tag} does not exist on selfix private registry!"
    tag = imageTag
  }
  return tag
}

def checkImageInfo(imageName, origTag) {
  status = 0
  sh "echo 'Tested Tag is ${imageName}:${origTag}' > archives/${imageName}-image-info.log"
  try {
    sh "docker image inspect --format='Size = {{.Size}} bytes' ${imageName}:${origTag} >> archives/${imageName}-image-info.log"
    sh "docker image inspect --format='Date = {{.Created}}' ${imageName}:${origTag} >> archives/${imageName}-image-info.log"
  } catch (Exception e) {
    echo "${imageName} Image tag to test (${imageName}:${origTag} does not exist!"
    status = 1
  }
  return status
}

def updateDockerCompose(filename) {
  for (ii = 0; ii < imageNames.size(); ii++) {
    sh 'sed -i -e "s@oaisoftwarealliance/' + imageNames[ii] + ':develop@' + imageNames[ii] + ':' + imageTags[ii] + '@" ' + filename
  }
}

def cleanUpDockerCompose(filename) {
  sh 'git checkout -- ' + filename
  sh 'docker network prune --force'
  sh 'docker volume prune --force'
}
